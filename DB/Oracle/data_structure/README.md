# 오라클의 데이터 구조

## 단순한 데이터 저장 방식의 문제점

어떤 테이블이든 상관없이 파일의 선두에서부터 데이터를 차례대로 넣어 두면 쉽게 구현할 수 있을 것처럼 보인다. 하지만 이런 방식으로 구현하면 이미 입력된 데이터의 크기를 크게 변경할 때 문제가 발생한다. 더욱이 데이터를 동시에 처리할 수도 없다.

- 데이터 관리나 I/O가 힘듬
- 사용하지 않는 공간의 관리가 힘듬

## 데이터 구조에 요구되는 사항

1. 관리 및 I/O 효율을 고려해 공간을 어느 정도의 크기로 뭉쳐서 할당하도록 한다.
2. 데이터 변경에 필요한 공간을 확보해 둔다.
3. 비어 있는 공간을 관리한다.

## 데이터 구조

![image](https://github.com/WonilLee211/TIL/assets/109330610/2f1a170f-e7bb-4e4e-860d-7357c24060e1)

![image](https://github.com/WonilLee211/TIL/assets/109330610/17c49654-e482-4b44-9ae5-399f844bb3c9)

크게 물리적 구조와 논리적 구조로 나뉜다.


물리적 구조는 데이터 파일 등 OS에서 보이는 구조를 의미한다.

논리적 구조는 OS에서 식별할 수 없는 오라클 내부의 구조를 의미한다.

- 데이터파일 안에 보관된 테이블이나 데이터는 논리적 구조임.


### 용어 정리

데이터베이스

- 테이블 스페이스의 집합과 리두 로그 파일, 컨트폴 파일로 구성된다.

테이블 스페이스(table space)

- 테이블이나 인덱스를 보관하기 위한 논리적 공간
- 한 개 이상의 세그먼트를 보관할 수 있다.
- 여러 데이터 파일로 구성될 수 있다.

세그먼트

- 테이블스페이스 내에서 데이터를 논리적으로 구분하는 단위
- 테이블, 인덱스, 로브, 클러스터 등의 세그먼트로 구성될 수 있음
- 한 세그먼트는 자신이 속한 테이블 스페이스 내 여러 데이터 파일에 걸쳐 저장될 수 있다.
    - 즉, 세그먼트에 할당된 **익스텐트가 여러 데이터 파일에 흩어져 저장되는 것**이며, 그래야 디스크 경합을 줄이고 I/O 분산 효과를 얻을 수 있다.

- 여러 세그먼트 확인
    - `SELECT SEGMENT_NAME, SEGMENT_TYPE, TABLESPACE_NAME FROM DBA_SEGMENT;`
    - `SELECT TABLESPACE_NAME, TOTAL_EXTENTS, TOTAL_BLOCKS FROM V$SORT_SEGMENT;`
        - 정렬용 세그먼트 검색
- 어떤 블록에 공간이 있는지 빠르게 확인하기 위해 세그먼트 단위로 빈 블록을 관리함
    - 세그먼트에 공간이 모자나란 상황에서 새로운 익스텐트를 추가하고 빈 블록을 추가함
    - `PCTFREE` : 세그먼트 파라미터인, 비어 있는 공간의 임계치보다 낮아지면 해당 블록에 대한 입력을 멈춤
    - `PCTUSED`: 이미 사용한 공간 임계치를 의미하는 세그먼트 파라미터로, 가득 찬 블록에서 데이터가 지속 삭제될 때 파라미터보다 낮아지면 해당 블록에 데이터 입력을 재개함

익스텐트(Extent)

- 세그먼트(테이블이나 인덱스)를 구성하는 논리적인 단위로서, 연속된 데이터 블록의 집합
- 데이터 파일 내에서 할당되고, 하나 이상의 데이터 블록으로 구성됨
- 첫 위치와 블록의 수만으로 데이터를 관리하여 관리 정보를 줄일 수 있음
- 데이터를 한 번에 읽어올 수 있고 테이블 풀스캔 성능을 향상시킬 수 있음


데이터 블록(Data Block)

- 데이터베이스의 최소 단위로서, 실제 데이터가 저장되는 논리적인 블록
- 일반적으로 여러 레코드를 포함하고, 데이터 액세스의 기본 단위가 됩니다.
    - **옵티마이저가 인덱스 기반 테이블 접근을 할지, full table scan을 할지 결정함에 있어 가장 중요한 판단 기준**은 레코드 수가 아닌, **블록 개수**

세그먼트 확장(Segment Extent)

- 세그먼트를 동적으로 확장하기 위해 사용되는 추가적인 익스텐트
- 데이터의 증가에 따라 필요한 공간을 동적으로 할당하여 세그먼트의 크기를 조정


## ROWID

데이터 행의 주소

데이터 파일 번호와 데이터 파일 안의 블록 번호, 블록 안에 행 번호와 같은 정보로 구성되어 있음

`SELECT ROWID, DBMS_ROWID.ROWID_RELATIVE_FNO(ROWID) file_no, DBMS_ROWID.ROWID_BLOCK_NUMBER(ROWID) block_no, DBMS_ROWID.ROWID_BLOCK_NUMBER(ROWID) row_no FROM TEST;`

- 위 SQL을 실행 시, 데이터파일 번호, 블럭 번호, 행 번호를 확인할 수 있다.

## 공간 할당과 빈 공간 관리

```sql
-- 1. 데이터베이스 생성
sql> create database test
-- 각 테이블 스페이스와 해당 테이블 스페이스를 구성하는 데이터 파일 이름과 크기가 지정됨

-- 2. 사용자용 테이블스페이스 생성
sql> create tablespace user01;
-- 크기가 지정된 50MB이며 로컬 관리라고 불리는 성능이 좋은 익스텐트 관리 모드로 지정함
sql> create tablespace user02;

-- 3. 테이블을 생성한 시점에서 첫 익스텐트가 할당됨
sql> create table TEST(no NUMBER, TEXT VARCHAR2(100));
-- 사용자가 가지고 있는 익스텐트를 조회하는 뷰
sql> select * FROM USER_EXTENTS WHERE TABLESPACE_NAME = 'user01';
-- SEGMENT_NAME PARTITION_NAME SEGMENT_TYPE TABLESPACE_NAME EXTENT_ID BYTES BLOCKS 정보를 조회할 수 있음

-- 4. 사용하지 않는 테이블 스페이스 추이
sql> select FILE_ID, BLOCK_ID, BLOCKS, BYTES FROM DBA_FREE_SPACE WHERE TABLESPACE_NAME = 'user01';
-- 테이블을 생성하게 되면 지정한 개수의 블록만큼 테이블 스페이스의 공간이 줄게 된다.
-- 테이블을 삭제하면 할당되었던 블록을 테이블 스페이스의 공간으로 반환된다.
```

