# 오라클 대기와 락

## 락이 필요한 이유

다중 처리를 실현하기 위해 **처리를 보호하는 것에 있다.**

```sql
select counter from counter_table where id = 1
for UPDATE;
-- 락이 걸림
update counter_table set counter = <새로운 값> where id = 1;
```

`for update` 키워드를 통해 id = 1인 행에 락이 걸리게 되고,

같은 행을 대상으로 한 update문, delete문, select for update문은 대기하게 된다.

커밋과 롤백할 때 행에 대한 락이 풀리게 된다.

위 코드를 아래와 같이 수정할 수 있다.

```sql
update counter_table set counter = counter + 1 where id = 1;
```

update문 등의 dml은 자동으로 락을 걸기 때문에 문제가 되지 않지만, 병렬 다중 실행이 발생하면
대기 락이 걸리게 된다.

## 대기와 락 대기

대기에는 3 가지가 있다.

1. 아이들 대기
    - 처리할 것이 없어서 쉬고 있는 대기
2. 아이들이 아닌 대기
    - 이유가 있어 어떨수 없이 하는 대기
    - 이상 상태 등 쓸데없이 SQL을 기다리게 하는 대기

<br>

### 대기 이벤트 과정

1. 오라클 클라이언트에서 sql 문을 데이터베이스에 던지고 결과를 기다림
2. 서버 프로세스에서 sql문이 도착할 때까지 SQL*Net message from client를 대기함
    - 도착하면 아이들 대기 이벤트 상태가 끝나며 처리를 시작함
    - sql 처리 도중이더라도 필요에 따라서는 I/O등의 대기 이벤트가 발생함
        - 데이터 파일에서 데잍러르 읽어오고 있는 'db file sequential read', 'db file scattered read'
        - 락을 기다리는 'enqueue'
        - 내부 락을 기다리는 'latch free'
3. 백그라운드 프로세스는 서버 프로세스로부터 부탁받기 전까지 아이들 상태
    - 'rdbms ipc message'를 기다리는 프로세스가 많음

<br>

### 아이들이 아닌 대기에 주의

- 예를 들어, 디스크 IO와 같은 SQL처리에 필요한 대기이다.
- SQL처리의 튜닝이라는 관점에서 `SQL에 걸린 시간 = 아이들이 아닌 대기 이벤트 + SQL 처리에 사용하는 CPU 시간`이다.

<br>

### 락에 의한 대기

- 대기는 락이 걸린 대상에 다시 락을 걸려고 했을 때 대기가 발생한다.
- 참고로 락은 `v$lock` 뷰 등으로 확인할 수 있다.
    - `v$lock`에서 `HEAD` 컬럼에 나타나면 락을 보유하고 있는 것
    - `v$lock`에서 `REQUESTED` 컬럼에 나타나면 락을 요청하고 있는 것
    - `v$lock`에서 `LOCK TYPE` 컬럼은 락의 종류를 의미함
        - `TX` : 행과 관련된 락
        - `TM` : 테이블에 거는 락
        등등 모드를 잘 조합할 때 상호배제를 잘 구현하고 동시성을 구현할 수 있다.


<br>

### 데드락의 구조

서로가 상대방이 보유하고 있는 락을 기다리느라 영원히 처리를 진행할 수 없는 상태

데드락일 때는 오라클에 의해 자동으로 한쪽의 처리가 롤백되며,

alert파일과 트레이스 파일에 정보가 표시됨

## 래치의 구조

다중처리를 구현하기 위한 락이다.

오라클 내부에서 자동으로 얻으며, sql을 한 번 실핼하기 위해서는 여러 래치를 얻고 해제하기를 반복해야 한다.

메모리나 데이터를 조작할 때 상호 배타적으로 처리하지 않으면 데이터가 손상될 수 있는 경우를 보호하고자 사용

래치는 병렬처리를 가능케하고 높은 처리량을 구현하기 위해 수십 수백 개가 존재함

<br>

### 래치의 경함

- 시스템이 대규모가 아닐 때 래치 경합이 심하다면 CPU 자원이 부족하거나 페이징 등 바람직하지 않은 상태인지 확인한다.
- 오라클을 제대로 운영하기 위해서는 토대가 되는 OS도 제대로 된 상태여야 한다.
    - 최근 OS는 여러 처리를 동시에 실행하는 멀티태스킹과 선점형 스케줄링이 당연시 되기 때문에 데드락 상황이 발생할 가능성이 높다.
